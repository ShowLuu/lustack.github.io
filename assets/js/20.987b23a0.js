(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{334:function(t,_,v){"use strict";v.r(_);var a=v(14),l=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"一、i-o基础篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、i-o基础篇"}},[t._v("#")]),t._v(" 一、I/O基础篇")]),t._v(" "),_("h2",{attrs:{id:"_1、网络通信原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、网络通信原理"}},[t._v("#")]),t._v(" 1、网络通信原理")]),t._v(" "),_("ul",[_("li",[t._v("C/S信息传输流程\n"),_("ul",[_("li",[t._v("客户端产生数据，存放于客户端应用的内存中，然后调用接口将自己内存中的数据发送/拷贝到操作系统内存(用户态->内核态)")]),t._v(" "),_("li",[t._v("客户端操作系统收到数据后，按照客户端应用指定的规则(协议)，调用网卡并发送数据")]),t._v(" "),_("li",[t._v("网络传输数据")]),t._v(" "),_("li",[t._v("服务端应用调用系统接口，想要将数据从操作系统内存拷贝到用户态内存中")]),t._v(" "),_("li",[t._v("服务端操作系统收到指定后，使用客户端相同的规则(协议)从网卡读取数据，然后拷贝给服务端应用(内核态->用户态)")])])])]),t._v(" "),_("h2",{attrs:{id:"_2、java-i-o演进之路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、java-i-o演进之路"}},[t._v("#")]),t._v(" 2、Java I/O演进之路")]),t._v(" "),_("ul",[_("li",[t._v("阻塞I/O模型\n"),_("ul",[_("li",[t._v("概述：用户进程请求获取数据，内核态从磁盘或者缓存读取数据，读取完毕，将数据拷贝到用户内存。整个过程用户进程一直等待。")]),t._v(" "),_("li",[t._v("典型应用：阻塞Socket，JavaBIO")]),t._v(" "),_("li",[t._v("特点：在I/O执行的两个阶段(内核态等待数据和内核台到用户态拷贝数据)都被阻塞")]),t._v(" "),_("li",[t._v("优点：\n"),_("ul",[_("li",[t._v("进程阻塞挂起不消耗CPU资源")]),t._v(" "),_("li",[t._v("实现难度低")]),t._v(" "),_("li",[t._v("适合并发量小的网络应用开发")])])]),t._v(" "),_("li",[t._v("缺点：\n"),_("ul",[_("li",[t._v("不适合并发量大的应用")]),t._v(" "),_("li",[t._v("需要为每个请求分配一个处理进程(线程)，线程上下文切换频繁，系统开销大")])])])])]),t._v(" "),_("li",[t._v("非阻塞I/O模型\n"),_("ul",[_("li",[t._v("概述：用户进程请求获取数据，他不会阻塞，而是立即返回。如果内核态数据已经准备好则返回数据；如果内核态数据没准备好则返回error，此时内核台开始工作(收集数据)，之后需要用户自己再去发送获取数据请求，获取数据，如果内核态数据准备好了，则将数据拷贝到用户内存，返回给用户")]),t._v(" "),_("li",[t._v("特点：用户进程需要不断地主动询问内核Kernel数据准备好了没")]),t._v(" "),_("li",[t._v("典型应用：Socket设置非阻塞NON_BLOCK")]),t._v(" "),_("li",[t._v("优点：\n"),_("ul",[_("li",[t._v("实现难度低，较阻塞稍难点。与阻塞I/O模型相比，需要编写更多的代码，但是，更具有灵活性上(控制建立多个连接、数据的收发量不均、时间不定时)")])])]),t._v(" "),_("li",[t._v("缺点：\n"),_("ul",[_("li",[t._v("进程轮询调用，消费CPU的资源")]),t._v(" "),_("li",[t._v("适合并发量较小且不需要及时响应的网络应用开发")])])])])]),t._v(" "),_("li",[t._v("多路复用I/O模型\n"),_("ul",[_("li",[t._v("概述：多个进程I/O注册到一个复用器Selector上，Selector会监听注册进来的所有I/O，当用户进程调用该Selector，如果Selector监听的所有I/O在内核态数据还没有可读的数据，select调用进程会被阻塞，而当任一I/O在哪喝缓冲区中有可读的数据时，select调用就会返回，之后select调用进程可以自己或通知另外的进程再次发起读取I/O，读取内核中准备好的数据，多个进程注册I/O后，只有一个select调用进程被阻塞")]),t._v(" "),_("li",[t._v("特点：对于每个Socket，一般都设置成非阻塞，但整个用户进程是一只被阻塞的，只不过进程是被select函数阻塞的，而不是被socket I/O阻塞")]),t._v(" "),_("li",[t._v("典型应用：Java NIO，Nginx(epoll、poll、select)")]),t._v(" "),_("li",[t._v("优点：\n"),_("ul",[_("li",[t._v("专一进程解决多个进程I/O的阻塞问题，性能好，Reactor模式")]),t._v(" "),_("li",[t._v("适合高并发服务应用开发，一个进程/线程响应多个请求")])])]),t._v(" "),_("li",[t._v("缺点：\n"),_("ul",[_("li",[t._v("实现和开发应用难度较大")])])])])]),t._v(" "),_("li",[t._v("信号驱动I/O模型\n"),_("ul",[_("li",[t._v("概述：进程预先告知内核，向哪喝注册一个信号处理函数，用户进程返回不会阻塞，当内核数据准备就绪时，会发送一个信号给进程，用户进程便在信号处理函数中调用I/O读取数据。")]),t._v(" "),_("li",[t._v("分析：实际上数据从内核态->用户态的过程中还是阻塞的，信号驱动I/O并没有实现真正的异步，因为通知到进程之后，依然由用户态进程完成I/O拷贝操作。这就是和异步I/O模型的区别。")]),t._v(" "),_("li",[t._v("特点：并不符合异步I/O要求，只能算是伪异步，并且实际中并不常用")]),t._v(" "),_("li",[t._v("缺点：应用少，实现和开发应用难度大")])])]),t._v(" "),_("li",[t._v("异步I/O模型\n"),_("ul",[_("li",[t._v("概述：用户进程请求获取数据，调用方法后，不会产生任何阻塞，内核进行准备数据，准备完成，将数据拷贝到用户内存，这一切都完成以后，内核通知用户进程。")]),t._v(" "),_("li",[t._v("分析：告知内核启动某个操作，并让内核在整个操作完成后(包括内核态数据拷贝到用户态)通知用户。")]),t._v(" "),_("li",[t._v("特点：真正实现了异步I/O，异步模型")]),t._v(" "),_("li",[t._v("典型应用：Java 7 AIO，高性能服务器应用")]),t._v(" "),_("li",[t._v("优点：\n"),_("ul",[_("li",[t._v("不阻塞，数据同步一步到位，采用Proactor模式")]),t._v(" "),_("li",[t._v("非常适合高性能、高并发应用")])])]),t._v(" "),_("li",[t._v("缺点：\n"),_("ul",[_("li",[t._v("需要操作系统低层能支持")]),t._v(" "),_("li",[t._v("实现和开发应用难度大")])])])])])]),t._v(" "),_("h1",{attrs:{id:"二、netty初体验"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、netty初体验"}},[t._v("#")]),t._v(" 二、Netty初体验")]),t._v(" "),_("h2",{attrs:{id:"_1、netty与nio-前世今生"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、netty与nio-前世今生"}},[t._v("#")]),t._v(" 1、Netty与NIO 前世今生")]),t._v(" "),_("h2",{attrs:{id:"_2、基于netty手写tomcat"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、基于netty手写tomcat"}},[t._v("#")]),t._v(" 2、基于Netty手写Tomcat")]),t._v(" "),_("h2",{attrs:{id:"_3、基于netty重构rpc框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、基于netty重构rpc框架"}},[t._v("#")]),t._v(" 3、基于Netty重构RPC框架")]),t._v(" "),_("h1",{attrs:{id:"三、netty核心篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、netty核心篇"}},[t._v("#")]),t._v(" 三、Netty核心篇")]),t._v(" "),_("h2",{attrs:{id:"_1、netty高性能之道"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、netty高性能之道"}},[t._v("#")]),t._v(" 1、Netty高性能之道")]),t._v(" "),_("h2",{attrs:{id:"_2、揭开bootstrap的神秘面纱"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、揭开bootstrap的神秘面纱"}},[t._v("#")]),t._v(" 2、揭开Bootstrap的神秘面纱")]),t._v(" "),_("h1",{attrs:{id:"四、netty实战篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、netty实战篇"}},[t._v("#")]),t._v(" 四、Netty实战篇")])])}),[],!1,null,null,null);_.default=l.exports}}]);